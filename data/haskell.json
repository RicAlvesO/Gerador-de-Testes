{
  "Questoes": [
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) enumFromTo :: Int -> Int -> [Int] que constr\u00f3i a lista dos n\u00fameros inteiros compreendidos entre dois limites.",
      "Resposta": "enumFromTo :: Int -> Int -> [Int]\nenumFromTo start end \n    | start > end = []\n    | otherwise = start : enumFromTo (start + 1) end",
      "Exemplo": {
        "Input": "enumFromTo 1 5",
        "Output": "[1,2,3,4,5]"
      }
    },
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) enumFromThenTo :: Int -> Int -> Int -> [Int] que constr\u00f3i a lista dos n\u00fameros inteiros compreendidos entre dois limites e espa\u00e7ados de um valor constante.",
      "Resposta": "enumFromThenTo :: Int -> Int -> Int -> [Int]\nenumFromThenTo start next end\n    | start > end && next > start || start < end && next < start || start == next && start > end = []\n    | otherwise = start : enumFromThenTo next (2 * next - start) end",
      "Exemplo": {
        "Input": "enumFromThenTo 1 3 10",
        "Output": "[1,3,5,7,9]"
      }
    },
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) (++) :: [a] -> [a] -> [a] que concatena duas listas.",
      "Resposta": "(++) :: [a] -> [a] -> [a]\n(++) [] l = l\n(++) (h:t) l = h : (++) t l",
      "Exemplo": {
        "Input": "(++) [1,2,3] [10,20,30]",
        "Output": "[1, 2, 3, 10, 20, 30]"
      }
    },
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) (++) :: [a] -> [a] -> [a] que concatena duas listas.",
      "Resposta": "(++) :: [a] -> [a] -> [a]\n(++) [] l = l\n(++) (h:t) l = h : (++) t l",
      "Exemplo": {
        "Input": "(++) [1,2,3] [10,20,30]",
        "Output": "[1, 2, 3, 10, 20, 30]"
      }
    },
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) (!!) :: [a] -> Int -> a que dada uma lista e um inteiro, calcula o elemento da lista que se encontra nessa posi\u00e7\u00e3o (assume-se que o primeiro elemento se encontra na posi\u00e7\u00e3o 0).\nIgnore os casos em que a fun\u00e7\u00e3o n\u00e3o se encontra definida (i.e., em que a posi\u00e7\u00e3o fornecida n\u00e3o corresponde a nenhuma posi\u00e7\u00e3o v\u00e1lida da lista).",
      "Resposta": "(!!) :: [a] -> Int -> a\n(!!) (h : _) 0 = h\n(!!) (_ : t) n = (!!) t (n - 1)",
      "Exemplo": {
        "Input": "(!!) [10, 20, 30] 1",
        "Output": "20"
      }
    },
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) reverse :: [a] -> [a] que dada uma lista calcula uma lista com os elementos dessa lista pela ordem inversa.",
      "Resposta": "reverse :: [a] -> [a]\nreverse [] = []\nreverse (h : t) = reverse t ++ [h]",
      "Exemplo": {
        "Input": "reverse [10,20,30]",
        "Output": "[30,20,10]"
      }
    },
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) take :: Int -> [a] -> [a] que dado um inteiro n e uma lista l calcula a lista com os (no m\u00e1ximo) n primeiros elementos de l.",
      "Resposta": "take :: Int -> [a] -> [a]\ntake _ [] = []\ntake n (h : t)\n  | n <= 0 = []\n  | otherwise = h : take (n - 1) t",
      "Exemplo": {
        "Input": "take 2 [10,20,30]",
        "Output": "[10,20]"
      }
    },
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) drop :: Int -> [a] -> [a] que dado um inteiro n e uma lista l calcula a lista sem os (no m\u00e1ximo) n primeiros elementos de l.",
      "Resposta": "drop :: Int -> [a] -> [a]\ndrop _ [] = []\ndrop n (h : t)\n  | n <= 0 = h : t\n  | otherwise = drop (n - 1) t",
      "Exemplo": {
        "Input": "drop 2 [10,20,30]",
        "Output": "[30]"
      }
    },
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) zip :: [a] -> [b] -> [(a,b)] que constr\u00f3i uma lista de pares a partir de duas listas.",
      "Resposta": "zip :: [a] -> [b] -> [(a, b)]\nzip [] _ = []\nzip _ [] = []\nzip (h : t) (h' : t') = (h, h') : zip t t",
      "Exemplo": {
        "Input": "zip [1, 2, 3] [10, 20, 30, 40]",
        "Output": "[(1, 10), (2, 20), (3, 30)]"
      }
    },
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) replicate :: Int -> a -> [a] que dado um inteiro n e um elemento x constr\u00f3i uma lista com n elementos, todos iguais a x.",
      "Resposta": "replicate :: Int -> a -> [a]\nreplicate 0 _ = []\nreplicate n x\n  | n < 0 = []\n  | otherwise = x : replicate (n - 1) x",
      "Exemplo": {
        "Input": "replicate 3 10",
        "Output": "[10,10,10]"
      }
    },
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) intersperse :: a -> [a] -> [a] que, dado um elemento e uma lista, constr\u00f3i uma lista em que o elemento fornecido \u00e9 intercalado entre os elementos da lista fornecida.",
      "Resposta": "intersperse :: a -> [a] -> [a]\nintersperse _ [] = []\nintersperse _ [h] = [h]\nintersperse x (h : t) = h : x : intersperse x t",
      "Exemplo": {
        "Input": "intersperce 1 [10, 20, 30]",
        "Output": "[10, 1, 20, 1, 30]"
      }
    },
    {
      "Pergunta": "Apresente uma defini\u00e7\u00e3o recursiva da fun\u00e7\u00e3o (pr\u00e9-definida) group :: Eq a => [a] -> [[a]] que agrupa elementos iguais e consecutivos de uma lista.",
      "Resposta": "group :: Eq a => [a] -> [[a]]\ngroup [] = []\ngroup (h : t) = (h : takeWhile (== h) t) : group' (dropWhile (== h) t)",
      "Exemplo": {
        "Input": "group [1, 2, 2, 3, 4, 4, 4, 5, 4]",
        "Output": "[[1], [2, 2], [3], [4, 4, 4], [5], [4]]"
      }
    }
  ],
  "Total": 12
}